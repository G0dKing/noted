PROJECT OVERVIEW

Title: "Noted" (working title subject to change)
Type: Full-stack Responsive Web/Mobile Application
Tagline: "The AI-Assisted Note-taking App for Creatives"
Scope: Small-scale, single-developer project with a $0 budget, designed to scale as needed in the future.
Tech-Stack:
	Frontend: React.js, Vite.js, HTML, CSS
	Backend: Node.js, Express.js

Objective: 
	Design, build, and deploy a fully-functioning Proof-Of-Concept for an AI-powered note-taking/organizational fullstack web application that demonstrates working implementations of all of the Features described subsquently within this Overview.

Features:
	1. Record your ideas by writing them down, recording your voice, or using text-to-speech. 
	2. Distraction-free, esthetically pleasing, minimalist, and modern UI.
	3. Format and style notes using Markdown or by using the intuitive, built-in rich-text editor.
	4. Use AI to get organzed by generating schedules, calendars, spread-sheets, budgets, or outlines.
	5. Enhance your creativity with an AI that generates plot/grammar/diction suggestions in the margin and learns as you write, evolving and adapting to your specific needs as a creator.
	6. Create, share, and download templates.
	7. Synchronize your notes on all devices using secure, encrypted cloud-storage.
	8. After finishing your book, story, poem, or document, immediately list it for sale as an e-book, hardcover/paperback, or as an audiobook read aloud by an artificially generated voice.
	9. Attach images or videos to notes.
	10. Set notes as private, or allow others to access them and make their own changes for a collaborative effort.
	11. Add user-created plugins and modifications for infinite expansion and functionality.

High-Level Roadmap:
	I. Phase One: Planning, Organization, Prepping Local and Cloud-based Environments for Development
	II. Phase Two: Create a "skeleton" of the app with basic functionality to serve as a foundation.
	III. Phase Three: Develop the application backend, integrate APIs and services, facillitate communication between elements, map out and develop application, network, and database infrastructures.
	IV. Phase Four: Develop and design a fully-featured, responsive frontend and connect it to the backend.
	V. Phase Five: Flesh out both the frontend and backend until it is fully-functional, aesthetically pleasing, and robust prototype/proof-of-concept.
	VI. Phase Six: Build a landing-page and website around the application.
	VII. Phase Seven: Begin debugging, closed/open alpha/beta tests, preview releases, reinforce security measures, implement optimizations, streamline website and application.
	VIII. Phase Eight: Version 1.0 Public Release
	IX. Phase Nine: Scale as needed, release patches/improvements, collect user feedback, maintain application security and integrity.
	X.Final Phase: Pitch the application to other businesses and ultimately sell it off, or build a business around the app and oversee operations or appoint others.

**Instructions for ChatGPT**

	Please refer to the preceding "PROJECT OVERVIEW" for context, then help the user achieve the stated Objective by providing accurate, specific, step-by-step, comprehensive instructions on how to efficiently and effectively complete each fundamental step of the development process. Do this by expanding and optimizing the High-Level Roadmap included above, then by breaking each section down into a series of submodules which, if followed sequentially and accurately, will inevitably result in the successful completion of the stated Objective. 
	
	Your level of helpfulness to the user can be maximized by:

		1. Further breaking-down each step of the development process into an ennumerated sequence of fundamental actions, omitting nothing, and making full use of the character limit allowed per response before moving on; if at any point a response requires more characters to deliver optimally than are allotted, simply divide the response into as many parts spread over as many responses as required to ensure a given topic is explained in full and exhaustive detail.

		2. Liberally including snippets containing real-world examples of functioning code, terminal commands, generated images, and links to resources as needed. Likewise, asking for more data, code examples, pictures, or other files or information as needed to contribute to providing the user with a response that is accurate, well-informed, verified as correct, and comprehensive to the user's utmost satisfaction.

		3. Filling knowledge gaps by performing web searches to research a given topic thoroughly and providing responses that you have verified via confirmation of your training-data by comparing it to external sources to ensure all provided information is accurate, up-to-date, correct, truthful, relevant, organized, and complete. Under no circumstances are you to provide responses containing incorrect information or data that cannot be confirmed by external sources available on the internet; it is far more helpful to simply inform the user that a piece of information is not included in your data-set, or cannot be confirmed, over supplying false information in a misguided attempt to please the user.

		4. Giving the user adequate time to follow along each step, and anticipating being asked questions, to analyze outputs, to debug errors, to correct and optimize user-provided code, and to provide additional citations or external resources throughout the course of the overall walkthrough.

		5. Fully analyzing the entirety of any documents or image files uploaded by the user, performing multiple analyses if needed, to ensure that any subsequent responses take into consideration the amalgamated entirety of these analyses, thereby reducing the liklihood of inaccurate or unhelpful responses on the basis of intentional or unintentional omission of both critical and non-critical information.

		6. Whenever possible, you may simply respond with a code snippet, providing the user with complete, working scripts, coding, or functions that can be copy/pasted or downloaded and executed by the user to automatically perform some or all of the process (or sequences of processes) relative to the preceding prompt.